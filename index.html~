<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>Scalesque by Noel Kennedy</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Scalesque</h1>
        <h2>Scala inspired functional programming for c#</h2>

        <section id="downloads">
          <a href="https://github.com/NoelKennedy/scalesque" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>Functional-programming in c#</h3>
		<p>Scalesque enables a functional-programming style in c#.  It is an open source micro library written in c# with no dependencies other than .net</p>
	 
	 	dfdf
	 			
		
		<h3>Features</h3>
		
		<h4>Option&lt;T&gt; : Replace null references with compiler enforced check</h4>
		<p>'Object reference not set to an instance of an object' - a <a href="http://qconlondon.com/london-2009/presentation/Null+References:+The+Billion+Dollar+Mistake">billion dollar mistake</a></p>
		<p>Option&lt;T&gt;, aka Maybe&lt;T&gt;, is a wrapper for optional references or values.  It works by using the type system to treat optional values differently.</p>
		<p>By using Option, instead of a null reference to an object, you are ensuring that programmers have to deal with the fact that your value maybe null.  In fact, they can't ignore it as their programs won't even compile unless they handle the case of None&lt;T&gt; where the value is missing.</p>
		
		<h4>Either&lt;T,U&gt;</h4>
		<p>Controls orthagonal results of program logic in a typesafe manner.  It avoids '<a href="http://www.joelonsoftware.com/items/2003/10/13.html">goto</a>' control flow.  A programmer is aware of all potential code paths in a routine at compile time.</p>
		
		<h4>Pattern matching</h4>
		<p>Scalesque's pattern matching controls program flow in a similar way to c#'s <a href="http://msdn.microsoft.com/en-us/library/06tc147t.aspx">switch-case statements</a>.  However, instead of just matching a variable to a literal, pattern matching allows you to match on anything you can think of.</p>
		replace this with clearer example and no comments		
		<img src="images/pattern_matching_example.PNG"/>
		<br/>
		<h4>Validation&lt;T,U&gt; : Compose logic without having to control progam logic</h4>
		<p>Scalesque validation allows you to compose a series of validating checks, without having 
		to implement any control flow.  It can behave in two different ways.  You can have it fail fast mode, and give you a successful result or the first failure.  Or you can chain your validations so you either get your validated results or a non empty list of strongly typed validation failures.</p>  
      </section>
      
      <section>
     	<ul>
     	<li>Faq</li>
     	<li>why functional</li>
     	<li>dependencies</li>
     	<li>walk through</li>
     	<li>implementation details?</li>
     	</ul>
      
      <h4>walk through skeleton</h4>
      
     	<h5>intro</h5>
     	<p>writing some demo code for a web server.  
     	fp - immutable threadsafe.  
     	easier to reason about
     	use static type system and compiler to improve correctness rather than programmer control flow, easier to reasoon about 
     	</p>
     	<h5>option</h5>
     	<p>abstraction of a querystring. making a wrapper on qs.
     	programmer calls get "blah" return Option
     	talk about null
     	working with the value as if it exists, but not caring if it doesnt until we need to know
     	getOrElse
     	compiler forces correctness, no surprises, no control forking, easier to reason about.
 
     	<h5>I need options people</h5>
     	<p>producing your own options - apply, .Some(), none()
     	help, this library don't place nice - opt(), or Option.apply()
     	dictionary wrappers, compare tryget malarky and get + getOrElse.
     	</p>
     	
     	<h5>FlatMap that s**t</h5>
     	i dont get trapped inside a monad.
     	show what happens when you get two options chaining.  
     	want either a some, or none.  
     	flatmap.  look at signature.
     	intuition, russian dolls. again, we use the compiler to show correctness.
     	show equivalent logic for .net dictionary getting 2 values. and then that scalaz spaceship method
     	<h5>Either</h5>
     	<p>It is absurd to divide people into good and bad. People are either charming or tedious.
Oscar Wilde</p>
		oscar certainly knew a thing or two about disjoint unions, and through his intuition we can now give a function a choice on its return type.
     		scenario is a request for a url.  
     	request handler calls router to check a url, router returns controller or 404. 
     	request handler projects right to controller, and calls process.
     	all program states handled by type system, no invisible forking. 
     	assumption of happy path until we need to perform union. but it is at a point when we have control over sensible defaults.  
     	conventional to treat right as happy path.
     	
     	<h5>Are you really a goto lover in disguise</h5>
     	either vs exception.
     	either logic easier to reason about and hoare quote: <p>"There are two ways of constructing a software
design: One way is to make it so simple that there are obviously no
deficiencies, and the other way is to make it so complicated that
there are no obvious deficiencies."
--C. A. R. Hoare</p> 

     
     	      <p>then change controller to return forbidden, or 200.  show join.</p>
     	      <h5>Help, I'm working with some exceptional libraries</h5>
     	      implement try() , use this to wrap exception producing calls.
     	      <h5>Pattern matching</h5>
     	      literals - same as switch
     	      extractors
     	      predicate
     	      


     	      
     	
     	
     	
     	
     	
     	
     	
      </section>
    </div>

    
  </body>
</html>