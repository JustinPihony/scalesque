<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>Scalesque by Noel Kennedy</title>
  </head>
  <body>

    <header>
      <div class="container">
        <h1>Scalesque</h1>
        <h2>Scala inspired functional programming for c#</h2>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
      <h3>Option&lt;T&gt;</h3>
      <h4>null</h4>
      <p>The man that invented null called it a billion dollar mistake.  It is frustrating to have your programs abort with the immortal phrase 'Object reference not set to an instance of an object'.  Often it is not clear why your program has halted on this problem.  Even given the actual source code line on which the exception has been triggered, there may be several object references, any of which could be the offending null reference.  Once you have identified the reference which is null, sometimes you will need to follow the code backwards to find out where that null reference came from, which could be from a completely different dll, based on some runtime state like data in a database.</p>
      <p>In short, null is a terrible idea.  It is easy to see why.  It does not adequately convey the legitimate program state of a optional value.  It is that concept that Option&lt;T&gt; elevates to a first class citizen in your code.  Option&lt;T&gt; represents the possibility that a value might be present or missing.</p>
      <h4>Abstracting a url querystring</h4>
      <p>A query string may or may not have a particular key in the context of a web call.  We can then define an abstraction over it with the following method signature:</p>
      
      <div><i>image here</i></div>
      
      <p>We ask the abstraction for a particular key, and it returns Option&lt;string&gt; which represents the value, if it is there.  </p>
      <h4>Option&lt;string&gt;, Some&lt;T&gt; and None&lt;T&gt;</h4>
      <p>In fact, Option&lt;T&gt; is an abtract class.  It has two subclasses, Some&lt;T&gt; and None&lt;T&gt;.  If our Option&lt;T&gt; is actually a Some&lt;T&gt; we know the reference within it is an actual reference to an object.  Alternatively, if we have a None&lt;T&gt;, we know we have a missing value.</p>
      <p>The temptation here, once we have an instance of Option&lt;T&gt;, might be to perform a type cast, or to ask the Option&lt;T&gt; if it has a value via it's HasValue property.  However, this doesn't actually move us on that far from just nulls.  Ok, we would have a better way of representing the potential of missing value than we had with null.  We know that developers using our api can't be caught out by null references, as their code now won't even compile without them dealing with Option&lt;T&gt;.  In fact, by using Option&lt;T&gt; we have given them much more than a heads up, we have given them the ability to use the type system to simplify their code.  Take a deep breath, here comes the <a href="http://en.wikipedia.org/wiki/Red_pill_and_blue_pill">red pill</a>.</p>
      <h4>Acting as though nothing is wrong</h4>
      <p>Once we have an Option&lt;T&gt;, we treat it <i>as if it had a value, even if it doesn't.</i>  We don't fork control flow based on whether the value is null or not, we just act as though we have a reference to an instance.  To most OO programmers this is downright odd state of affairs, and a strange way of thinking about state.</p>  
      <p>In terms of the types in scalesque, we are going to assume that our Option&lt;T&gt; is actually a, Some&lt;T&gt;, and ignore the fact that it might actually be a None&lt;T&gt;. Once we are at a position in our code to actually require a value, as opposed to a possibility of a value, we will deal with the fact our Option&ltT&gt; might have had a missing value all along.</p>
      <div><i>need some code getting an id out of the query string, getting celberity do from db, and then getting favorite colour of celebrity, or black</i></div>
      <h4>Can't Map; won't Map</h4>
      <p>If you need a value straight away then you need it straight away.  You don't always have to .Map yourself to victory.  You can call GetOrElse() on an Option&lt;T&gt; providing some suitable default value.  Where you should be mapping as shown above, if where you need to more complex branching logic for some vs none. The technique above simplifies your code to by removing conditional branching, and having the type system do it for you.  You can unify the two code forks by calling GetOrElse, or Fold when it is most convenient to do so.  Fold is equivalent to a Map then GetOrElse.</p>
      
      <h4>Next up</h4>
      <p>So far we have only shown how to work with an Option&lt;T&gt; once we have one.  The <a href="walkthrough-option-creation.html">next section stays with Option&lt;T&gt;</a> and shows you how to create instances of Some&lt;T&gt; or None&lt;T&gt; yourself.</p>
      </section>
    </div>

    
  </body>
</html>